name: Fetch and Compile Sing-Box Rules (Python Edition)

on:
  workflow_dispatch:
  schedule:
    - cron: "30 22 * * *" # 6:30 AM UTC+8
  push:
    branches:
      - main
    paths-ignore:
      - "**/README.md"

permissions:
  contents: write

env:
  SING_BOX_VERSION: 1.12.12
  MIHOMO_VERSION: 1.19.17

jobs:
  sync_and_compile:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout the repository
        uses: actions/checkout@v3

      - name: Set up Git user
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Install Tools (Sing-box & Mihomo)
        run: |
          # Install Sing-box
          curl -Lo sing-box.tar.gz https://github.com/SagerNet/sing-box/releases/download/v${SING_BOX_VERSION}/sing-box-${SING_BOX_VERSION}-linux-amd64.tar.gz
          tar -xzf sing-box.tar.gz
          sudo mv sing-box-${SING_BOX_VERSION}-linux-amd64/sing-box /usr/local/bin/sing-box
          rm -rf sing-box*
          
          # Install Mihomo
          curl -Lo mihomo.gz https://github.com/MetaCubeX/mihomo/releases/download/v${MIHOMO_VERSION}/mihomo-linux-amd64-v3-v${MIHOMO_VERSION}.gz
          gunzip mihomo.gz
          chmod +x mihomo
          sudo mv mihomo /usr/local/bin/mihomo

      - name: Clone Rule Sources
        run: |
          git clone --depth 1 https://github.com/SukkaLab/ruleset.skk.moe.git ruleset_src
          git clone -b sing --single-branch --depth 1 https://github.com/MetaCubeX/meta-rules-dat.git meta_src

      # ----------------------------------------------------------------
      # 处理 Sing-box 规则 (Updated)
      # ----------------------------------------------------------------
      - name: Process Sing-Box Rules
        shell: python
        run: |
          import json
          import os
          import shutil
          import subprocess
          from pathlib import Path

          # --- 配置 ---
          BASE_DIR = Path('.')
          SUKKA_SRC = BASE_DIR / 'ruleset_src/sing-box'
          META_SRC = BASE_DIR / 'meta_src'
          WORK_DIR = BASE_DIR / 'sing'

          # 定义要移除的垃圾字符串/水印
          JUNK_STRINGS = {
              "7h1s_rul35et_i5_mad3_by_5ukk4w-ruleset.skk.moe",
              "this_ruleset_is_made_by_sukkaw.ruleset.skk.moe"
          }

          # 重建目录
          if WORK_DIR.exists(): shutil.rmtree(WORK_DIR)
          WORK_DIR.mkdir(parents=True)
          (WORK_DIR / 'sukka').mkdir()
          (WORK_DIR / 'metacubex/domainset').mkdir(parents=True)
          (WORK_DIR / 'metacubex/domainset/notcn').mkdir()
          
          print(">>> Moving Files...")
          
          # 1. 移动 Sukka 文件
          for item in SUKKA_SRC.glob('*'):
              shutil.move(str(item), str(WORK_DIR / 'sukka' / item.name))

          # 2. 移动 MetaCubeX 文件
          meta_mapping = {
              'geo-lite/geosite/*.json': 'metacubex/domainset',
              'geo/geosite/cn.json': 'metacubex/domainset',
              'geo/geosite/gfw.json': 'metacubex/domainset',
              'geo/geosite/geolocation-!cn.json': 'metacubex/domainset/notcn/notcn.json',
              'geo/geosite/cloudflare.json': 'metacubex/domainset/cloudflare.json',
              'geo/geosite/cloudflare-cn.json': 'metacubex/domainset/cloudflare-cn.json',
              'geo/geosite/googlefcm.json': 'metacubex/domainset/googlefcm.json',
              'geo/geosite/google.json': 'metacubex/domainset/google.json',
              'geo/geosite/google-cn.json': 'metacubex/domainset/google-cn.json',
              'geo/geosite/google@cn.json': 'metacubex/domainset/google@cn.json',
          }

          for src_pattern, dest_rel in meta_mapping.items():
              if '*' in src_pattern:
                  parent = (META_SRC / src_pattern).parent
                  pattern = Path(src_pattern).name
                  for f in parent.glob(pattern):
                      shutil.move(str(f), str(WORK_DIR / dest_rel / f.name))
              else:
                  src_file = META_SRC / src_pattern
                  if src_file.exists():
                      dest_path = WORK_DIR / dest_rel
                      if dest_path.suffix == '.json': 
                          shutil.move(str(src_file), str(dest_path))
                      else:
                          shutil.move(str(src_file), str(dest_path / src_file.name))

          if (BASE_DIR / 'own').exists():
              shutil.copytree(str(BASE_DIR / 'own'), str(WORK_DIR / 'own'), dirs_exist_ok=True)

          print(">>> Processing JSON files...")

          # 3. 遍历并清洗 JSON
          for json_file in WORK_DIR.rglob('*.json'):
              try:
                  with open(json_file, 'r', encoding='utf-8') as f:
                      data = json.load(f)
              except json.JSONDecodeError:
                  continue

              is_modified = False

              # [MetaCubeX] Version Upgrade
              if 'metacubex' in str(json_file) and data.get('version') == 1:
                  data['version'] = 2
                  is_modified = True

              if 'rules' in data:
                  cleaned_rules = []
                  for rule in data['rules']:
                      # 0. 移除 process_name
                      if 'process_name' in rule:
                          del rule['process_name']
                          is_modified = True

                      # [Sukka] reject.json 移除 domain_keyword
                      if json_file.name == 'reject.json' and 'domain_keyword' in rule:
                          del rule['domain_keyword']
                          is_modified = True

                      # 1. 深度清洗：移除 JUNK 字符串 & 移除空 Key
                      # 我们使用 list(rule.keys()) 来创建一个键的副本，以便在循环中安全删除
                      keys_to_remove = []
                      
                      for key in list(rule.keys()):
                          val = rule[key]
                          
                          # 只有列表类型才需要过滤字符串
                          if isinstance(val, list):
                              # A. 过滤垃圾字符串 / juejin
                              # 如果是字符串列表，检查是否在 JUNK_STRINGS 中
                              original_len = len(val)
                              val = [x for x in val if str(x) not in JUNK_STRINGS]
                              
                              # 特殊逻辑：reject.json 移除 juejin
                              if json_file.name == 'reject.json' and key in ['domain', 'domain_suffix']:
                                  val = [x for x in val if 'juejin' not in str(x)]

                              # B. [Sukka] domainset/non_ip 移除 ip_cidr
                              if key == 'ip_cidr' and 'sukka' in str(json_file) and ('domainset' in str(json_file) or 'non_ip' in str(json_file)):
                                  val = [] # 强制清空，稍后会被下面的逻辑删除

                              # 更新列表（如果发生了变化）
                              if len(val) != original_len:
                                  rule[key] = val
                                  is_modified = True
                              
                              # C. 如果列表变为空，标记删除该 Key
                              if len(val) == 0:
                                  keys_to_remove.append(key)

                      # 执行删除空 Key 的操作
                      for k in keys_to_remove:
                          del rule[k]
                          is_modified = True

                      # 2. 检查规则是否还有效
                      # 至少应该包含一种匹配条件 (domain, ip_cidr, etc) 
                      # 如果 rule 只剩下 process_path 或 source_port 等，或者彻底为空，视情况保留或丢弃
                      # 这里简单判定：如果 rule 变成了空字典，或者只剩个别无用字段，就丢弃
                      if rule: 
                          cleaned_rules.append(rule)
                  
                  if len(data['rules']) != len(cleaned_rules):
                      data['rules'] = cleaned_rules
                      is_modified = True

              # 保存更改
              if is_modified:
                  with open(json_file, 'w', encoding='utf-8') as f:
                      json.dump(data, f, indent=2, ensure_ascii=False)
              
              # 删除空文件
              if not data.get('rules') or len(data['rules']) == 0:
                  print(f"Deleting empty file: {json_file}")
                  json_file.unlink()

          print(">>> Compiling Rules...")
          
          # 4. 编译
          for srs in WORK_DIR.rglob('*.srs'): srs.unlink()

          for json_file in WORK_DIR.rglob('*.json'):
              print(f"Compiling {json_file.name}...")
              result = subprocess.run(
                  ["sing-box", "rule-set", "compile", str(json_file)],
                  capture_output=True, text=True
              )
              if result.returncode != 0:
                  print(f"Error compiling {json_file}: {result.stderr}")
                  exit(1)

      - name: Push Sing-Box Rules
        run: |
          cd sing
          git init
          git checkout -b sing
          git add .
          git commit -m "Released on $(date --rfc-3339=seconds)"
          git remote add origin "https://${{ github.actor }}:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}"
          git push -f -u origin sing

      # ----------------------------------------------------------------
      # 处理 Mihomo 规则 (Updated)
      # ----------------------------------------------------------------
      - name: Process Mihomo Rules
        shell: python
        run: |
          import os
          import shutil
          import subprocess
          from pathlib import Path

          BASE_DIR = Path('.')
          SUKKA_SRC = BASE_DIR / 'ruleset_src/Clash'
          WORK_DIR = BASE_DIR / 'mihomo'
          
          # 定义垃圾字符串
          JUNK_STRINGS = {
              "7h1s_rul35et_i5_mad3_by_5ukk4w-ruleset.skk.moe",
              "this_ruleset_is_made_by_sukkaw.ruleset.skk.moe"
          }

          if WORK_DIR.exists(): shutil.rmtree(WORK_DIR)
          WORK_DIR.mkdir(parents=True)
          (WORK_DIR / 'sukka').mkdir()

          print(">>> Moving Mihomo Files...")
          for item in SUKKA_SRC.glob('*'):
              target = WORK_DIR / 'sukka' / item.name
              if item.is_dir():
                  shutil.copytree(item, target, dirs_exist_ok=True)
              else:
                  shutil.copy2(item, target)

          print(">>> Cleaning Text Rules...")
          
          for txt_file in WORK_DIR.rglob('*.txt'):
              with open(txt_file, 'r', encoding='utf-8') as f:
                  lines = f.readlines()
              
              new_lines = []
              is_ip_folder = 'sukka/ip' in str(txt_file).replace('\\', '/')
              
              for line in lines:
                  content = line.strip()
                  
                  # 过滤垃圾字符串
                  found_junk = False
                  for junk in JUNK_STRINGS:
                      if junk in content:
                          found_junk = True
                          break
                  if found_junk: continue
                  
                  if 'juejin' in content and txt_file.name == 'reject.txt': continue
                  
                  if is_ip_folder:
                      if content.startswith('IP-CIDR'):
                          parts = content.split(',')
                          if len(parts) >= 2:
                              new_lines.append(parts[1] + '\n')
                  else:
                      new_lines.append(line)

              if not new_lines:
                  print(f"Deleting empty file: {txt_file}")
                  txt_file.unlink()
                  continue

              with open(txt_file, 'w', encoding='utf-8') as f:
                  f.writelines(new_lines)

              rule_type = 'ipcidr' if is_ip_folder else 'domain'
              mrs_path = txt_file.with_suffix('.mrs')
              
              print(f"Compiling {txt_file.name} as {rule_type}...")
              result = subprocess.run(
                  ["mihomo", "convert-ruleset", rule_type, "text", str(txt_file), str(mrs_path)],
                  capture_output=True, text=True
              )
              # Error handling tailored for non-critical failures if needed

      - name: Push Mihomo Rules
        run: |
          cd mihomo
          git init
          git checkout -b mihomo
          git add .
          git commit -m "Released on $(date --rfc-3339=seconds)"
          git remote add origin "https://${{ github.actor }}:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}"
          git push -f -u origin mihomo